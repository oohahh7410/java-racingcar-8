# 자동차 경주 게임

n대의 자동차가 주어진 횟수만큼 전진 또는 정지를 반복하며 경주하는 콘솔 프로그램입니다.  
각 자동차는 무작위 값(0~9)에 따라 전진 여부를 결정하며, 4 이상이면 전진합니다. 모든 라운드가 끝나면 가장 멀리 이동한 자동차(들)가 우승합니다.

## 주요 기능

- **자동차 이름 입력**: 쉼표(,)로 구분된 자동차 이름을 입력받습니다(각 1자 이상, 5자 이하).
- **시도 횟수 입력**: 1 이상의 정수를 입력받습니다.
- **유효성 검증**: 이름 중복, 공백, 길이 초과, 잘못된 횟수 입력 시 예외 메시지를 출력하고 프로그램을 종료합니다.
- **게임 진행**: 각 라운드마다 모든 자동차의 전진/정지 여부를 판단하고 위치를 하이픈(`-`)으로 출력합니다.
- **우승자 결정**: 가장 많이 전진한 자동차를 우승자로 선정하며, 공동 우승자를 모두 표시합니다.

## 실행 예시

```
경주할 자동차 이름을 입력하세요.(이름은 쉼표(,) 기준으로 구분)
pobi,woni,jun
시도할 횟수는 몇 회인가요?
5

실행 결과
pobi : -
woni : 
jun : -

pobi : --
woni : -
jun : --

pobi : ---
woni : --
jun : ---

pobi : ----
woni : ---
jun : ----

pobi : -----
woni : ----
jun : -----

최종 우승자 : pobi, jun
```

## 코드 구조

1주차에서의 입력–로직–출력 분리를 바탕으로, 2주차에는 도메인 중심으로 구조를 재설계했습니다.  
특히 **`StringParser`를 제거**하고, **`Cars`가 스스로 입력을 파싱**하도록 변경했습니다(코드와 README 동기화).

```
src/main/java
└── racingcar
    ├── Application.java              (프로그램 시작 및 예외 처리)
    ├── controller
    │   └── RacingGameController.java (입력/도메인/출력 조율)
    ├── domain
    │   ├── Car.java                  (자동차 1대: 이름, 위치, 이동)
    │   ├── Cars.java                 (자동차 일급 컬렉션: 생성/검증/이동/우승자)
    │   └── RoundCount.java           (시도 횟수 검증 및 보관)
    ├── util
    │   └── RandomUtils.java          (난수 생성)
    └── view
        ├── InputView.java            (사용자 입력)
        └── OutputView.java           (결과 출력)
```

## 설계 및 구현 의도

### 1) 도메인 객체에 책임을 위임
- `Car`는 자신의 이름을 생성자에서 검증하고, 전달받은 난수로 전진 여부를 판단합니다.
- `Cars`는 입력 문자열을 직접 파싱해 자동차 목록을 생성하고, 이름 중복을 검증하며, 전체 이동과 우승자 계산을 담당합니다.
- 컨트롤러는 흐름만 조율하고 도메인 내부 구현은 알지 않아도 됩니다.

### 2) **TDD를 위한 설계 변경: `car.move()` → `car.move(int randomNumber)`**
- 초기에는 `Car` 내부에서 난수를 직접 조회하는 `move()`를 사용했습니다.
- 이 경우 전진/정지 로직의 단위 테스트가 어려워졌습니다(난수에 강하게 결합).
- **개선**: `Cars`가 `RandomUtils.getRandomNumber()`로 난수를 구해 **숫자 자체**를 `Car.move(int)`에 전달하도록 변경했습니다.
- **결과**: `Car`는 난수 생성에 대한 의존이 사라져 `CarTest`에서 `move(4)`(전진), `move(3)`(정지)처럼 **완전히 예측 가능한 테스트**가 가능해졌습니다. TDD 사이클에 자연스럽게 들어맞습니다.

### 3) 일급 컬렉션 `Cars`의 역할
- 단순 `List<Car>` 대신 `Cars`로 감싸 입력 파싱, 이름 중복 검증, 전체 이동, 우승자 판별 등을 한 곳에서 처리합니다.
- 컨트롤러는 “자동차들을 움직여라”, “우승자를 알려줘”라는 메시지 수준만 다룹니다.

### 4) 사용자 친화적인 예외 메시지
- 콘솔 사용자 경험을 고려해 기계적 태그 대신 자연스러운 평서문 메시지를 사용했습니다.  
  예) “자동차 이름은 5자 이하여야 합니다.”, “시도 횟수는 1 이상이어야 합니다.”

## 테스트 구성

- **CarTest**: 이름 검증, 이동 조건(전진/정지), 위치 표시
- **CarsTest**: 입력 파싱, 중복 검증, 전체 이동, 단독/공동 우승자 계산
- **RoundCountTest**: 시도 횟수 입력 검증(숫자/범위/공백)
- **ApplicationTest**: 실제 실행 흐름 및 예외 처리 검증

난수 기반 로직은 `assertRandomNumberInRangeTest()`를 사용해 전진/정지 시나리오를 제어함으로써 **재현 가능한 테스트**를 보장했습니다.

## 배운 점

- 1주차의 기능 분리를 넘어, 2주차에서는 **객체 간 협력과 책임 분배**를 설계의 중심에 두었습니다.
- **TDD 관점의 설계 변경**(난수 주입 방식 분리)이 테스트 가능성과 가독성을 함께 끌어올린다는 점을 확인했습니다.
- indent depth 2와 작은 메서드 원칙을 지키며, 변경 영향 범위를 좁게 유지하는 방법을 익혔습니다.
- 다음 과제에서는 테스트를 먼저 작성하는 흐름(TDD)을 더 철저히 적용해 보겠습니다.
